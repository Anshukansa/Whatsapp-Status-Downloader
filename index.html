import telebot
from telebot import types
import pandas as pd
from datetime import datetime, timedelta
import pytz
import logging
import os

# Bot configuration
BOT_API_TOKEN = "7629707339:AAEHormLX7UhRdD54n5D3VLfjGViCAN7CJY"  # Replace with your actual Bot API token
ALLOWED_USERS = [7932502148]  # Replace with actual allowed user IDs
excel_file_path = "Phone_Management.xlsx"  # Path to the Excel file


# Logging setup
logging.basicConfig(filename='bot_errors.log', level=logging.ERROR)

# Initialize bot and load Excel
bot = telebot.TeleBot(BOT_API_TOKEN)
df = None

def log_error(error_message):
    logging.error(f"{datetime.now()} - {error_message}")

# Function to check if user is allowed
def is_user_allowed(message):
    return message.from_user.id in ALLOWED_USERS

# Function to load Excel file
def load_excel(file_path):
    if os.path.exists(file_path):
        df = pd.read_excel(file_path)
        return df
    else:
        # Initialize an empty DataFrame with the required columns if the file doesn't exist
        columns = ["Index", "Status", "Serial Number", "Model", "Storage", "Battery Health", "Description",
                   "Purchase Price", "Sell Price", "Profit", "Purchase Date", "Ad Date", "Sell Date"]
        df = pd.DataFrame(columns=columns)
        return df

# Function to save DataFrame to Excel
def save_excel(df, file_path):
    df.to_excel(file_path, index=False)

# Load or initialize the DataFrame
df = load_excel(excel_file_path)

# PURCHASE ENTRY FUNCTION
def purchase_entry(serial_number, model, storage, battery_health, description, purchase_price, purchase_date):
    global df
    new_entry = {
        "Index": len(df) + 1,  # Auto-incremented index
        "Status": "Not Listed",
        "Serial Number": serial_number,
        "Model": model,
        "Storage": storage,
        "Battery Health": battery_health,
        "Description": description,
        "Purchase Price": purchase_price,
        "Sell Price": None,
        "Profit": None,
        "Purchase Date": purchase_date,
        "Ad Date": None,
        "Sell Date": None
    }
    # Append the new entry to the DataFrame
    df = df._append(new_entry, ignore_index=True)
    # Save to Excel
    save_excel(df, excel_file_path)
    print("Purchase entry added and saved to Excel.")

# Function to update Ad Date by Serial Number
def update_ad_entry(serial_number, ad_date):
    global df
    if serial_number in df['Serial Number'].values:
        df.loc[df['Serial Number'] == serial_number, 'Ad Date'] = ad_date
        save_excel(df, excel_file_path)
        print(f"Ad Date updated for Serial Number {serial_number}")
    else:
        print(f"Serial Number {serial_number} not found in the DataFrame.")

# Function to update Sell Price and Sell Date by Serial Number
def update_sell_entry(serial_number, sell_price, sell_date):
    global df
    if serial_number in df['Serial Number'].values:
        # Update both the Sell Price and Sell Date
        df.loc[df['Serial Number'] == serial_number, 'Sell Price'] = sell_price
        df.loc[df['Serial Number'] == serial_number, 'Sell Date'] = pd.to_datetime(sell_date)
        save_excel(df, excel_file_path)
        print(f"Sell Price and Sell Date updated for Serial Number {serial_number}")
    else:
        print(f"Serial Number {serial_number} not found in the DataFrame.")


# CONFIRM AND UPDATE FUNCTION
def confirm_and_update(message, update_function, serial_number, *args):
    # Call the update function with necessary arguments
    update_function(serial_number, *args)

    # Show full entry details after the update
    show_full_entry(message.chat.id, serial_number)


# SHOW FULL ENTRY FUNCTION
def show_full_entry(chat_id, serial_number):
    global df
    # Fetch the full entry corresponding to the serial number
    entry = df[df['Serial Number'] == serial_number].iloc[0]

    # Format the entry details nicely
    entry_details = (
        f"âœ… *Entry Details Updated*:\n"
        f"ðŸ”¢ *Serial Number*: {entry['Serial Number']}\n"
        f"ðŸ“± *Model*: {entry['Model']}\n"
        f"ðŸ’¾ *Storage*: {entry['Storage']} GB\n"
        f"ðŸ”‹ *Battery Health*: {entry['Battery Health']}%\n"
        f"ðŸ’¬ *Description*: {entry['Description']}\n"
        f"ðŸ’µ *Purchase Price*: ${entry['Purchase Price']}\n"
        f"ðŸ’° *Sell Price*: ${entry['Sell Price']} (if available)\n"
        f"ðŸ—“ *Purchase Date*: {entry['Purchase Date'].strftime('%d-%m-%Y') if pd.notnull(entry['Purchase Date']) else 'N/A'}\n"
        f"ðŸ—“ *Ad Date*: {entry['Ad Date'].strftime('%d-%m-%Y') if pd.notnull(entry['Ad Date']) else 'N/A'}\n"
        f"ðŸ—“ *Sell Date*: {entry['Sell Date'].strftime('%d-%m-%Y') if pd.notnull(entry['Sell Date']) else 'N/A'}\n"
    )

    # Send the nicely formatted entry details
    bot.send_message(chat_id, entry_details, parse_mode='Markdown')

# Cancel operation anytime
def cancel_operation(message):
    if message.text.lower() == "/cancel":
        bot.send_message(message.chat.id, "Operation canceled. No changes made.")
        return True
    return False

# Start command
@bot.message_handler(commands=['start'])
def send_welcome(message):
    if is_user_allowed(message):
        markup = types.ReplyKeyboardMarkup(one_time_keyboard=True)
        markup.add('Purchase', 'Update Ad', 'Sell', 'Report')
        bot.send_message(message.chat.id, "Welcome! Choose an action:", reply_markup=markup)
    else:
        bot.send_message(message.chat.id, "Access Denied.")

# PURCHASE ENTRY
@bot.message_handler(func=lambda message: message.text == 'Purchase')
def handle_purchase(message):
    if is_user_allowed(message):
        bot.send_message(message.chat.id, "Enter Serial Number:")
        bot.register_next_step_handler(message, get_serial_number)
    else:
        bot.send_message(message.chat.id, "Access Denied.")

def get_serial_number(message):
    if cancel_operation(message):
        return
    serial_number = message.text
    bot.send_message(message.chat.id, "Enter Model:")
    bot.register_next_step_handler(message, get_model, serial_number)

def get_model(message, serial_number):
    if cancel_operation(message):
        return
    model = message.text
    bot.send_message(message.chat.id, "Enter Storage (e.g., 128):")
    bot.register_next_step_handler(message, get_storage, serial_number, model)

def get_storage(message, serial_number, model):
    if cancel_operation(message):
        return
    storage = validate_storage(message.text)
    if storage:
        bot.send_message(message.chat.id, "Enter Battery Health (0-100):")
        bot.register_next_step_handler(message, get_battery_health, serial_number, model, storage)
    else:
        bot.send_message(message.chat.id, "Invalid storage. Enter a number:")
        bot.register_next_step_handler(message, get_storage, serial_number, model)

def get_battery_health(message, serial_number, model, storage):
    if cancel_operation(message):
        return
    battery_health = validate_battery_health(message.text)
    if battery_health is not None:
        bot.send_message(message.chat.id, "Enter Description:")
        bot.register_next_step_handler(message, get_description, serial_number, model, storage, battery_health)
    else:
        bot.send_message(message.chat.id, "Invalid battery health. Enter a number between 0-100:")
        bot.register_next_step_handler(message, get_battery_health, serial_number, model, storage)

def get_description(message, serial_number, model, storage, battery_health):
    if cancel_operation(message):
        return
    description = message.text
    bot.send_message(message.chat.id, "Enter Purchase Price:")
    bot.register_next_step_handler(message, get_purchase_price, serial_number, model, storage, battery_health, description)

def get_purchase_price(message, serial_number, model, storage, battery_health, description):
    if cancel_operation(message):
        return
    purchase_price = validate_price(message.text)
    if purchase_price:
        bot.send_message(message.chat.id, "Enter Purchase Date (dd-mm):")
        bot.register_next_step_handler(message, get_purchase_date, serial_number, model, storage, battery_health, description, purchase_price)
    else:
        bot.send_message(message.chat.id, "Invalid price. Enter a positive number:")
        bot.register_next_step_handler(message, get_purchase_price, serial_number, model, storage, battery_health, description)

def get_purchase_date(message, serial_number, model, storage, battery_health, description, purchase_price):
    if cancel_operation(message):
        return
    purchase_date = validate_and_format_date(message.text)
    if purchase_date:
        confirm_and_update(message, purchase_entry, serial_number, model, storage, battery_health, description, purchase_price, purchase_date)
    else:
        bot.send_message(message.chat.id, "Invalid date format. Please enter again (dd-mm):")
        bot.register_next_step_handler(message, get_purchase_date, serial_number, model, storage, battery_health, description, purchase_price)

# AD DATE UPDATE
@bot.message_handler(func=lambda message: message.text == 'Update Ad')
def handle_update_ad(message):
    if is_user_allowed(message):
        bot.send_message(message.chat.id, "Enter Serial Number for which you want to update the Ad Date:")
        bot.register_next_step_handler(message, get_ad_serial_number)
    else:
        bot.send_message(message.chat.id, "Access Denied.")

def get_ad_serial_number(message):
    if cancel_operation(message):
        return
    serial_number = message.text
    if serial_number_exists(serial_number):
        bot.send_message(message.chat.id, "Enter Ad Date (dd-mm):")
        bot.register_next_step_handler(message, get_ad_date, serial_number)
    else:
        bot.send_message(message.chat.id, "Serial number not found. Please try again.")
        bot.register_next_step_handler(message, get_ad_serial_number)

def get_ad_date(message, serial_number):
    if cancel_operation(message):
        return
    ad_date = validate_and_format_date(message.text)
    if ad_date:
        confirm_and_update(message, update_ad_entry, serial_number, ad_date)
    else:
        bot.send_message(message.chat.id, "Invalid date. Please enter again (dd-mm):")
        bot.register_next_step_handler(message, get_ad_date, serial_number)

# SELL ENTRY UPDATE
@bot.message_handler(func=lambda message: message.text == 'Sell')
def handle_sell_entry(message):
    if is_user_allowed(message):
        bot.send_message(message.chat.id, "Enter Serial Number for which you want to update Sell Price and Sell Date:")
        bot.register_next_step_handler(message, get_sell_serial_number)
    else:
        bot.send_message(message.chat.id, "Access Denied.")

def get_sell_serial_number(message):
    if cancel_operation(message):
        return
    serial_number = message.text
    if serial_number_exists(serial_number):
        bot.send_message(message.chat.id, "Enter Sell Price:")
        bot.register_next_step_handler(message, get_sell_price, serial_number)
    else:
        bot.send_message(message.chat.id, "Serial number not found. Please try again.")
        bot.register_next_step_handler(message, get_sell_serial_number)

def get_sell_price(message, serial_number):
    if cancel_operation(message):
        return
    sell_price = validate_price(message.text)
    if sell_price:
        bot.send_message(message.chat.id, "Enter Sell Date (dd-mm):")
        bot.register_next_step_handler(message, get_sell_date, serial_number, sell_price)
    else:
        bot.send_message(message.chat.id, "Invalid price. Enter a positive number:")
        bot.register_next_step_handler(message, get_sell_price, serial_number)

def get_sell_date(message, serial_number, sell_price):
    if cancel_operation(message):
        return
    sell_date = validate_and_format_date(message.text)
    if sell_date:
        confirm_and_update(message, update_sell_entry, serial_number, sell_price, sell_date)
    else:
        bot.send_message(message.chat.id, "Invalid date. Please enter again (dd-mm):")
        bot.register_next_step_handler(message, get_sell_date, serial_number, sell_price)

# VALIDATION FUNCTIONS
def validate_storage(storage):
    try:
        return int(storage)
    except ValueError:
        return None

def validate_battery_health(health):
    try:
        health_int = int(health)
        return health_int if 0 <= health_int <= 100 else None
    except ValueError:
        return None

def validate_price(price):
    try:
        return int(price) if int(price) > 0 else None
    except ValueError:
        return None

def validate_and_format_date(input_date, purchase_date=None):
    try:
        australia_tz = pytz.timezone('Australia/Sydney')
        current_year = datetime.now(australia_tz

).year
        date = datetime.strptime(f"{input_date}-{current_year}", "%d-%m-%Y")
        if purchase_date and date < purchase_date:
            return None
        return date
    except ValueError:
        return None

# UTILITY FUNCTIONS
def serial_number_exists(serial_number):
    return serial_number in df['Serial Number'].values

# def confirm_and_update(message, update_function, *args):
#     # This will send a confirmation message and if confirmed, call the appropriate update function
#     update_function(*args)
#     show_full_entry(message.chat.id, *args)  # After update, show full entry

# def show_full_entry(chat_id, *args):
#     # Placeholder function for displaying the full entry after updating
#     bot.send_message(chat_id, "Full entry details: " + str(args))

# REPORT
@bot.message_handler(func=lambda message: message.text == 'Report')
def handle_report(message):
    if is_user_allowed(message):
        bot.send_message(message.chat.id, "Generating report...")
        # Placeholder for report logic
        bot.send_message(message.chat.id, "Report generated.")
    else:
        bot.send_message(message.chat.id, "Access Denied.")

# Run the bot
bot.polling()
